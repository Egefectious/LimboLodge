class_name ScoreManager extends Node

var game_board: Control
var total_score_label: Label
var score_accumulated: int = 0
var base_points_paid: Dictionary = {} # Tracks if a specific cell's base score has been added to total

func _init(board: Control, label: Label):
	game_board = board
	total_score_label = label

func run_score_sequence(result: Dictionary, cells: Array):
	score_accumulated = 0
	base_points_paid.clear()
	AudioManager.reset_pitch()
	
	# --- 1. IDENTIFY ORPHANS ---
	# Orphans are cells that are NOT part of any winning line
	var line_indices = {}
	for line in result.line_details:
		var indices = _get_indices_from_name(line.type)
		for idx in indices:
			line_indices[idx] = true
			
	# --- 2. SCORE ORPHANS ---
	for i in range(25):
		if Global.placed_slabs[i] != null and not line_indices.has(i):
			await _play_cell_score(i, cells[i])
			# Small pause between orphans
			await game_board.get_tree().create_timer(0.1).timeout

	# --- 3. SCORE LINES ---
	# Sort lines: smaller wins first, big wins last for dramatic effect
	var lines = result.line_details.duplicate()
	lines.sort_custom(func(a, b): return a.bonus < b.bonus)
	
	for line in lines:
		var indices = _get_indices_from_name(line.type)
		var line_base_sum = 0
		
		# A. Animate each slab in the line
		for idx in indices:
			if Global.placed_slabs[idx] != null:
				# Visual: pop the number
				var slab_points = _get_slab_points(idx)
				line_base_sum += slab_points
				
				# Audio/Visual Pop
				_spawn_visual_for_cell(idx, cells[idx], slab_points)
				
				# LOGIC: If this slab hasn't paid its base tax to the Total Score yet, do it now
				if not base_points_paid.has(idx):
					_add_to_total(slab_points)
					base_points_paid[idx] = true
				
				# Rhythm: Fast sequence
				await game_board.get_tree().create_timer(0.1).timeout
		
		# B. Show Line Summary (The "Ping Ping Ping")
		var center = _get_center_pos(indices, cells)
		
		# 1. Show Base Sum
		var txt_sum = _spawn_text("Base: " + str(line_base_sum), center, Color.WHITE, FloatingText.Type.NORMAL)
		AudioManager.play("slide")
		await txt_sum.finished
		
		# 2. Show Multiplier (Explosion)
		var txt_mult = _spawn_text("x" + str(line.multiplier), center, Color("#ffaa00"), FloatingText.Type.MULT)
		AudioManager.play("win") # Big sound
		await game_board.get_tree().create_timer(0.4).timeout # Wait for impact
		
		# 3. Add Bonus to Total (The rapid count up)
		# The bonus is the EXTRA points generated by the multiplier
		# Total Line Value = Base * Mult
		# Bonus = (Base * Mult) - Base ... OR just Base * (Mult - 1)
		# Our logic adds Base to total immediately, so we just add the Bonus now.
		var bonus = line.bonus
		_rapid_score_add(bonus) 
		
		# 4. Show Floating Total
		_spawn_text("+" + str(bonus), center + Vector2(0, 40), Color.GOLD, FloatingText.Type.LINE_TOTAL)
		
		await game_board.get_tree().create_timer(0.3).timeout

	# Finish
	await game_board.get_tree().create_timer(0.5).timeout

# --- ANIMATION STEPS ---

func _play_cell_score(idx: int, cell: Control):
	var points = _get_slab_points(idx)
	_spawn_visual_for_cell(idx, cell, points)
	
	# Add to total
	_add_to_total(points)
	base_points_paid[idx] = true
	
	# Wait for animation to mostly finish
	await game_board.get_tree().create_timer(0.2).timeout

func _spawn_visual_for_cell(idx: int, cell: Control, points: int):
	var is_perfect = Global.is_perfect_match(idx)
	var pos = cell.global_position + Vector2(37, 10)
	
	if is_perfect:
		_spawn_text("Perfect! +" + str(points), pos, Color("#ffff00"), FloatingText.Type.PERFECT)
		AudioManager.play_sequential("place", 0.1)
		_flash_cell(cell, Color.YELLOW)
	else:
		_spawn_text(str(points), pos, Color.WHITE, FloatingText.Type.NORMAL)
		AudioManager.play_sequential("place", 0.05)
		_flash_cell(cell, Color.WHITE)

func _rapid_score_add(amount: int):
	# "Ping ping ping" effect
	var steps = 5
	var step_val = amount / steps
	for i in range(steps):
		score_accumulated += step_val
		total_score_label.text = "SCORE: " + str(score_accumulated)
		AudioManager.play("place", Vector2(1.5 + (i*0.1), 1.5 + (i*0.1))) # High pitch pings
		_pulse_label()
		await game_board.get_tree().create_timer(0.05).timeout
	
	# Ensure clean total at end
	score_accumulated += (amount % steps)
	total_score_label.text = "SCORE: " + str(score_accumulated)

# --- HELPERS ---

func _get_slab_points(idx: int) -> int:
	var slab = Global.placed_slabs[idx]
	var points = slab.number
	var is_perfect = Global.is_perfect_match(idx)
	var row = idx / 5
	var is_letter = (slab.letter == ["L","I","M","B","O"][row])
	
	if is_perfect: points += 25
	elif is_letter: points += 10
	return points

func _spawn_text(val: String, pos: Vector2, col: Color, type) -> FloatingText:
	var txt = FloatingText.new()
	game_board.add_child(txt)
	txt.setup(val, pos, col, type)
	return txt

func _add_to_total(amount: int):
	score_accumulated += amount
	total_score_label.text = "SCORE: " + str(score_accumulated)
	_pulse_label()

func _pulse_label():
	var t = game_board.create_tween()
	t.tween_property(total_score_label, "scale", Vector2(1.2, 1.2), 0.05)
	t.tween_property(total_score_label, "scale", Vector2(1.0, 1.0), 0.05)

func _flash_cell(cell, color):
	var bg = cell.get_node_or_null("Background")
	if bg:
		var t = game_board.create_tween()
		t.tween_property(bg, "modulate", color, 0.1)
		t.tween_property(bg, "modulate", Color.WHITE, 0.2)

func _get_indices_from_name(name: String) -> Array:
	var indices = []
	if name.begins_with("Horizontal"): # Changed from Row to match Global.gd
		var r = int(name.split(" ")[2]) - 1
		for c in range(5): indices.append(r * 5 + c)
	elif name.begins_with("Vertical"):
		var c = int(name.split(" ")[2]) - 1
		for r in range(5): indices.append(r * 5 + c)
	elif "Diagonal \\" in name: indices = [0, 6, 12, 18, 24]
	elif "Diagonal /" in name: indices = [4, 8, 12, 16, 20]
	return indices

func _get_center_pos(indices: Array, cells: Array) -> Vector2:
	if indices.is_empty(): return Vector2(640, 360)
	var sum = Vector2.ZERO
	for idx in indices: sum += cells[idx].global_position
	return (sum / indices.size()) + Vector2(37, 37)
